#CopyOnWriteArrayList
这是一个 线程安全的 ArrayList，  因为 它 进行的 修改操作都是在 底层的一个 复制的数组（快照）上进行的。
也就是 ， 写时复制 策略。

![img_18.png](img_18.png)
- 存在一个array数组存放具体元素
- ReentrantLock 独占锁来控制 同时只有一个线程 对array 进行修改。

如果让我们自己做一个写时复制的线程安全的 list我们会怎么做，有哪些点需要考虑?
- 何时 初始化list ？ 大小是多少？ list 是有限大小吗？
- 如何保证 线程安全 ？ 
- 如何 保证 使用 迭代器 遍历list 时，数据 一致性。

带着 疑问 来看看  CopyOnWriteArrayList 是怎么设计的。

## add方法源码：
![img_19.png](img_19.png)


在如上代码中，调用 add 方法的线程 会首先 执行代码( 1) 去获取独占锁，
如果 多个 线程都调用 add方法则只有一个线程会获取到该锁，其他线程会被阻塞挂起直到锁被释放。
所以 一 个线程获取到锁后，就保证了在 该线程添加元素的过程中其他线程不会对 array 进行修改。
线程获取锁后执行代码（2)获取 array， 

然后执行代码( 3)复制 array 到一个新数组 (从这里可以知道新数组的大小是原来数组大小增加 1，所以 CopyOnWriteArrayList是无 界 list)，并把新增的元素添加到新数组。
然后执行代码( 4)使用新数组替换原数组，并在返回前释放锁。由于加了锁，所以 整个 add 过程是个原子性操作。需要注意的是，在添加元素时，首先复制了 一个快照，然 后在快照上进行添加，而不是直接在原来数组上进行。

## set方法：
1. 获取独占锁，阻止其他线程进行修改
2. 通过get方法获取指定位置元素， 跟 新set 的值比较。
   - 不一样则，创建新数组，直接set 新值；
   - 一样的话，由于保证 volatile语义，也要重新set array。 （？？？）
3. 释放锁    
    
Q： 新值跟 旧值一样，为什么也要 新建数组 set？
因为 前面加锁，并没有 给 array 加锁， 所以 多线程下 这个 array 可能会被 其他线程修改。
从而破坏 了  线程安全。因此，即使set方法中的值没有发生改变，也应该创建新数组以保证volatile语义和线程安全性。 

tips:
Volatile语义是Java中的一种语义，用于保证一个变量在多线程环境下的可见性。

当一个变量被声明为volatile时，编译器和处理器都会注意到这个变量是共享的，并且可能被不同的线程同时访问。因此，在进行读写操作时，需要采用适当的同步措施来保证数据的一致性。

换句话说，volatile语义主要是为了确保：
- 对一个volatile变量的修改，对于所有线程都是可见的。
- 当一个线程修改了一个volatile变量时，其他线程可以正确读取到该变量的值。
因此，volatile语义是用来保证线程间数据同步的一种重要手段。

## remove方法：
1. 获取独占锁
2. 找到 需要被删除的 元素
3. 把剩余的元素 copy 到新数组，然后 set array
4. 释放锁


## 弱一致性的 迭代器

弱一致性指的是： 返回迭代器后，其他线程对 list 的 增删改 对迭代器是不可见的。

原因就是因为： 修改期间 会 copy 新数组，重新set ， 其他线程 迭代器 获取的则 是 旧数组。


## 总结

- 使用 写时复制 保证 list 一致性。
- 由于 获取，修改，写入 并不是原子的， 所以 用到  独占锁
- 提供了 弱一致性的迭代器。
![img_20.png](img_20.png)
CopyOnWriteArraySet 利用了  CopyOnWriteArrayList 实现。
  

#HashMap


#ConcurrentHashMap





