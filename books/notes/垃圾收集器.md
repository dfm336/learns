如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的实践者。
各款经典收集器之间关系如图，存在连线说明可以搭配使用。
![img_1.png](img_1.png)

没有最好的，万能的收集器，只能根据场景选择最合适的。

# Serial 收集器
Serial是最基础、历史最悠久的收集器。这是一款 单线程 工作的收集器，
单线程 并不仅仅是 说明它只会 使用一个处理器 或者 一个收集器 线程 去进行 GC工作。
更应该强调，它 在 GC工作时， 需要 "Stop The World"。  这项工作时 虚拟机 后台自动发起的，
在用户不可知， 不可控的情况下， 把 用户的工作线程 全部停掉。 这对很多应用来说是不可接受的。
![img_2.png](img_2.png)

但是对于 Hotspot 的设计者来说，是可以理解"Stop The World"的。你总不能一边清理垃圾，一边又 制造垃圾吧。

但是 都为着 消除或降低 GC时 停顿用户线程的 时间而努力着。

Serial  -》 Parallel -》 CMS 和 G1 -》 Shenandoah 和 ZGC 
一步一步的， 都 没有办法 根除 Stop The world


虽然 Serial 最早，但至今 也是 HopSpot 运行在客户端模式下的 默认  新声代  收集器。
优点就是， 它 简单 高效（对于 其他的 单线程 而比）。
对于内存资源受限的环境，它是 所有 收集器里 额外 消耗内存 最小的；
对于单核处理器或者核心较少的环境来说，Serial由于没有 线程交互的开销，专心GC 自然可以获得 最高的 单线程收集效率。

桌面应用，一般分配给 jvm的内存不会太多， 新生代的内存就更少，一般 几十 或者一两百 MB。 垃圾收集的停顿完全可以控制在 十几、几十毫秒
以内。 只要不是频繁收集， 这个 停顿时间 是完全可以接受的。
所以  Serial 对于 客户端 Jvm来说 是一个 很好的 选择。

# ParNew 收集器
ParNew其实是 Serial的多线程并行版本。除了 同时 使用多条线程进行GC外，其余 都跟 Serial一致。
![img_3.png](img_3.png)

ParNew 除了 多线程 并行收集之外，对比Serial并没有太多创新。但是在jdk1.7之前，它却是 服务端 Hotspot的首选收集器。
有一个 跟性能无关的  很大原因就是： 除了 Serial ，只有它 能跟  CMS搭配工作。

可以说是CMS的出现才巩固了ParNew 的地位。但成也萧何，败也萧何。随着更先进的G1 (-带着CMS的继承者和替代者的 光环)的出现。
G1由于是一个  面向全堆的 收集器， 不需要 新生代收集器 的配合。
所以 JDK9开始  G1替代 了 ParNew+CMS 。   ParNew+CMS就不再是 官方推荐的服务端模式 解决方案了。


# Parallel Scavenge收集器
这也是一款 新生代收集器。 基于  标记-复制 算法。 能并行收集的 多线程收集器。
这样看起来，跟 ParNew 非常相似。 但它有个 非常显著的特点就是： 
- Parallel Scavenge收集器的目标是：达到一个可控制的吞吐量。更关注 高吞吐。

所谓吞吐量就是：
吞吐量  =   （运行用户代码的时间） / (GC时间 +  运行用户代码时间)

- 停顿时间越短，就适合 需要与用户交互 或者 需要保证 服务响应时间 的程序。
- 高吞吐则适合 最高效的 利用服务器 处理器 资源，尽快完成良好的 运算任务。主要适合 后台运算 而不需要 太多交互的程序。

由于 与吞吐量关系密切，所以 Parallel Scavenge 也经常被称为 ： 吞吐量优先收集器。

存在一个JVM参数：-XX:+UseAdaptiveSizePolicy
这是一个开关参数， 当这个  参数被激活， 就不要人工指定 新生代大小（-Xmm)、Eden区Survivor区的比例（-XX:Survivor Ratio)
以及 晋升老年代对象的大小（-XX:PretenureSizeThreshold)等细节参数了。 
虚拟机 会 自动根据 当前运行 情况手机 性能监控信息，动态调整这些参数 以提供最合适的停顿时间  或者 最大吞吐量。
这种方式 称为 垃圾收集的 自适应调节 策略。

新手手工优化存在困难时，就可以选择 这个策略。 使用 Parallel Scavenge 收集器 配合 自适应调节策略， 把内存管理
的调优任务 交给 虚拟机 完成。  只需要 设置 基础的 内存数据， 如：  -Xmx 最大堆。
然后使用  -XX：MaxGCPauseMillis 参数（更 关注 最大停顿时间）  或  -XX:GCTimeRatio (更关注 吞吐量)  给 自适应策略 一个优化目标

# Serial Old 收集器
一看这名字就知道， 这是 Serial 收集器的 老年代版本。 同样是一个 单线程收集器，使用 标记整理算法。
主要意义同 Serial 一样，也是主要 客户端 模式下的  Hotspot 使用。

两个用户：
1. Jdk5之前 跟 Parallel Scavenge 搭配使用。（其实 在 Parallel Scavenge中 有内置的 PS MarkSweep 来进行老年代收集，但是它跟 Serial Old实现几乎一样）
2. 作为CMS 收集发生失败后 的 后备预案。

# Parallel Old 收集器
这 是 Parallel Scavenge 的老年代版本。 支持 多线程 并发收集，基于 标记-整理。 这个收集器是jdk6才提供的。

在jdk6 Parallel old 还未出现之前。  Parallel Scavenge 一直比较尴尬， 老年代 除了 Serial old 以为 别无选择。
然而 由于 Serial old 在服务端性能上的 拖累， 使用 Parallel Scavenge 也未必 就能 整体上 获得 吞吐量 最大化的效果。

也由于， 单线程的 老年代 收集 中，无法 充分了用 服务器 多核处理器的 并行处理能力。 在 老年代 内存空间很大 而且 硬件规格比较
高级的 老年代 内存中，  这种 组合的 吞吐量  甚至 不一定 比 ParNew + CMS 组合来的 优秀。

知道 Parallel Old 才 算是 有了 名副其实 的 "吞吐量优先收集器" 搭配。
所以， 在 注重 吞吐量 或者 处理器资源 稀缺的 场合 都可以 考虑  Parallel Scavenge + Parallel Old 的组合。
![img_4.png](img_4.png)


# CMS 收集器
CMS(Concurrent Mark Sweep)收集器 是一种  获取 最短回收停顿时间 为目标的  收集器。
很大一部分 B/S架构应用， 都比较关注 响应速度 ， CMS 就非常适合。

从 CMS 名字 Mark Sweep就知道  CMS 基于 标记-清除  算法实现的。
运作过程：
1. 初始标记 ： 需要Stop The world 。 标记GC Roots， 速度很快
2. 并发标记 ：  根据GC Roots 开始 遍历 整个对象图。  耗时较长，但是 可以 跟 用户线程 并发
3. 重新标记 ： 需要Stop The world。 修正 并发标记 阶段 因为 用户线程继续运行 导致 的 一些 引用变更 带来的 标记错误。采用增量更新。耗时 比初始标记长一点，比并发标记 短
4. 并发清除 ： 清理 前面 标记的 死亡对象，由于 不需要 移动存活对象， 所以 也是能跟 用户线程 并发的。


整个 过程 耗时最长的 是：  并发标记 ， 并发清除。 由于 这连个 阶段 都是可以 跟用户线程并发的。
所以 整体上来说， CMS的 内存回收过程 是 与 用户线程 并发的。
![img_5.png](img_5.png)

CMS是一款相当优秀的收集器： 并发收集、低停顿。

CMS 是Hotspot 对于 低停顿的 一次成功的尝试，但是 还 远远打不到 完美，至少三个明显缺点：
1. 对处理器资源非常敏感，一般的，并发程序都对处理器资源敏感。并发阶段，虽然不会Stop the  wordld，但是 会占用了更多线程，占用了处理器的计算能力。导致应用程序变慢，降低总吞吐量。
2. 会产生浮动垃圾，因为并发-标记 和 并发-清除 阶段，用户线程 是在运行的，会导致 新的垃圾对象产生。导致cms无法清理这些浮动垃圾，只能下次GC清理。
3. 总体上，由于 GC阶段 用于线程需要运行，所以需要预留 内存给 用户线程，所以 CMS不能 像其他收集器一样，老年代几乎满了 才去收集（这样就没内存给 用户线程用了）。
    3.1 可以通过一个参数，-XX:CMSInitiatingOccu-pancyFraction的值 来提高CMS的触发百分比，降低内存回收频率，获取更好的性能
    3.2 如果 这个参数过大，导致 GC 阶段 用户能使用的内存较少，少到 已经无法满足 用户线程 分配新对象 的需要， 就会出现一次并发失败。
    3.3 并发失败后， 就会 启动 后备预案： 冻结用户线程执行，临时 启用 serial old 来进行 老年代 收集。
4. 有与 cms采用标记-清除， 就会产生 大量内存碎片。会导致，大对象 分配 麻烦，出现老年代还有很多空间（碎片），却无法分配出一个 连续的足够大 的空间。而不得不 提前触发 "full GC"
    4.1 为了解决内存碎片问题，CMS收集器提供了一个-XX:+UseCMS-CompactAtFullCollection开关参数(默认是开启的，此参数从 JDK 9开始废弃
    4.2 这个参数，让 CMS 在 由于内存碎片 导致的 提前Full GC 时， 开启 内存 碎片 整理过程。 由于 内存整理（通过移动 对象），是无法跟 用户线程并发的。就也 导致 停顿时间更长了。
    4.3 于是 就想办法， 让 这个整理过程 频率降低一点， 不是在 每次Full GC 都执行。 指定一定频率执行。-XX:CM SFullGCsBefore- Compaction(此参数从JDK 9开始废弃）默认0
  


" 前面都基于 内存整理-需要移动搞对象， 暂停用户线程，无法 并发执行，导致 增大 停顿。  
在Sh e n a n d o a h 和 Z G C 出现后， 就改变了，能 并发执行。
   

# Garbage First-G1
G1是 垃圾收集器 技术发展 历史 里程碑 式的结果。 它  开创了 收集器 面向 局部收集的 收集思路 和 基于 Region 的内存布局。

