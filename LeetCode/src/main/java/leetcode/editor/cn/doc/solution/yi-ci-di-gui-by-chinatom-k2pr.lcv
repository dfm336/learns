# 递归分析

重排的直观思路是，一个指针从head，一个从tail分别向中间访问合并，直到中间节点，但是单链表不指向其前驱节点，所以没办法直接实现该方式。

但如果使用递归遍历链表时，**递归函数执行完成回溯到方法时，本质上实现了从后继向前访问**，而如果我们**利用递归函数的返回值实现从头部向后的访问**，就实现了同步从head和tail向中间访问，并且节点一一对应。

# 递归过程简图

![image.png](https://pic.leetcode-cn.com/1636201951-eohXGr-image.png)

# 代码

* []

```java
    public void reorderList(ListNode head) {
        reorderList(head, head);
    }

    private ListNode reorderList(ListNode head, ListNode tail) {
        // 如果tail为null，说明已经递归到链表尾部，这时候需要重新连接尾部节点与头部节点，故返回head
        if (tail == null) return head;
        // 一直递归到尾部
        ListNode returnNode = reorderList(head, tail.next);
        // 回溯到方法，returnNode即为与tail对应的正向访问节点
        // 如果returnNode是null，说明处理完成，直接返回
        if (returnNode == null) {
            return null;
        }
        // 如果returnNode或returnNode的后继等于tail，说明完成，注意tail即为尾节点，next需要set null
        if (returnNode == tail || returnNode.next == tail) {
            tail.next = null;
            return null;
        }

        // 将尾部遍历节点指向对应的头部遍历节点的next，正向节点指向尾部遍历节点
        tail.next = returnNode.next;
        returnNode.next = tail;
        // 返回头部向后访问的下一节点
        return tail.next;
    }
```

该方法实际上等同于使用栈或线性表等将链表存储起来，完成后，再从栈或线性表的尾部开始往回处理。
