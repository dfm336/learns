# 分代收集理论
当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”(Generational Collection)的理论进 行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分 代假说之上:
1) 弱分代假说(Weak Generational Hypothesis):绝大多数对象都是朝生夕灭的。 
2) 强分代假说(Strong Generational Hypothesis):熬过越多次垃圾收集过程的对象就越难以消
亡。
   
于是便有了多款垃圾收集器的一致原则：
    收集器应该将Java堆划分出不同的区域。然后将回收对象依据其年龄(年龄即对象熬过垃圾收集过程的次数)分配到不同的区域之中存储
- 如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那 么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对 象，就能以较低代价回收到大量的空间
- 如果剩下的都是难以消亡的对象，那把它们集中放在一块， 虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有 效利用。


Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域
因此 有了 Minor GC ， Major GC  ，Full GC 的划分。

也才能 根据 不同的区域 产生不同的垃圾收集算法。


分代之后，要注意 跨代引用。

加入现在在新生代 进行一次 Minor GC ，但 新生代的 对象 完全是可能被 老年代引用的。所以 不得不 在
原有的 GC Roots 上 ，再去  老年代中 遍历，寻找 是否有 老年代对象 引用了 新生代对象。

反过来，回收老年代，也一样，需要 注意 新生代是否 存在引用 老年代的对象。

这样 无疑 增加了 很大的 负担。

为了解决这个问题，就需要对分 代收集理论添加第三条经验法则:

3) 跨代引用假说(Intergenerational Reference Hypothesis):跨代引用相对于同代引用来说仅占极 少数。

这其实就是起前面两条假说的 隐含推理：
1. 存在互相引用 关系的 两个对象，应该  倾向于 同生死的。
- 比如，存在新生代对象 引用了 老年代对象， 由于 老年代 存活， 新生代对象不会被回收，多次以后，也会进入老年代。这时候就没有跨代引用了


依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录 每一个对象是否存在及存在哪些跨代引用。
只需在新生代上建立一个全局的数据结构(该结构被称 为“记忆集”，Remembered Set)。
这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会 存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。
虽然这种方法需要在对象改变引用关系(如将自己或者某个属性赋值)时维护记录数 据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的
 
部分收集(Partial GC):指目标不是完整收集整个Java堆的垃圾收集，其中又分为:
- 新生代收集(M inor GC/Young GC):指目标只是新生代的垃圾收集。
- 老年代收集(Major GC/Old GC):指目标只是老年代的垃圾收集。目前只有CMS收集器会有单 独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指， 读者需按上下文区分到底是指老年代的收集还是整堆收集。
- 混合收集(Mixed GC):指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收 集器会有这种行为。
- 整堆收集(Full GC):收集整个Java堆和方法区的垃圾收集。


注意：分代收集理论也有其缺陷，最新出现(或在实验中)的几款垃圾收集器都展现出了 面向全区域收集设计的思想，或者可以支持全区域不分代的收集的工作模式。

# 标记-清除算法
最基础的垃圾收集算法，后续算法都基于这个改进。
两个阶段
-  标记： 判定对象是否需要回收后，进行标记。可标记需要回收的，也可标记 不需要回收的
-  清除： 根据标记清除需要回收的对象。

主要缺点：
- 执行效率不够稳定。标记和 清除 过程 的  执行效率，都随着堆中对象增长 而降低。
- 会产生 内存碎片。标记、清除之后会产生大 量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找 到足够的连续内存而不得不提前触发另一次垃圾收集动作


# 标记-复制
标记复制算法常简称为 复制算法。
为了 解决  标记-清楚 两个缺点。 
把可用内存划分为 两半。每次只使用 其中的一半，当这一半的内存 用完，就将 还存活的对象
复制 到 另一半区域，然后把 已经使用的这一半 区域 一次清理掉。
" 如果每次用完时， 存活的对象 比较多，那么 复制到另一半区域 带来的开销就比较大了。

由于是半区复制， 就不会有 内存碎片，分配内存时，直接移动 堆顶指针，顺序分配就好。

缺点：显而易见，每次只能利用一半的内存。 空间浪费。这是因为 这里是 1：1分配的。

后续 的  8： 1： 1 就让可用空间更大。

# 标记-整理
标记复制 由于 在 对象存活率比较 高的时候，需要 很多 复制操作，导致 效率降低。
更关键的是， 如果 不想浪费 50%的 空间，就 需要对 额外的空间进行 分配担保。以免 被使用的一半内存中的 对象都存活 这种极端情况。
所以 老年代，一般 不使用   复制 算法。 

针对老年代，存活率高 的特性， 产生了 另一种  标记-整理 算法。 
标记过程 ，同 标记-清楚一样。
但是 后续过程 不是 直接 对  可回收对象 进行清理，而是   让 所有存活 的对象，向内存空间的 一端移动，直接清理掉 边界以外的对象（这些对象就是 需要回收的）。

标记-整理  是 移动式回收算法。

是否移动 回收后的对象，是一个 优缺点并存的 风险决策 。
- 如果 移动这些存活对象，尤其是老年代，有大量存活对象。那么 移动 存活对象，并更新所有 引用这些对象 的地方，将会是 极为负重的操作，因为要 更新引用，所以需要 Stop the world .
- 如果想 标记-清楚 算法一样，完全 不移动和整理 存活对象，导致内存碎片问题。 就只能依靠 更为复杂的 内存分配器 和内存访问器 来解决。
1. 例如： 通过 "分区空闲分配链表" 来解决内存分配问题。原理同：计算机硬盘存储大文件就不要求物理连续的磁盘空间，能够在碎片化的硬盘上存储和访问就是通过硬盘分区表实现的。

内存的访问 是用户程序 最为频繁的操作，没有之一。 假如 在这个环节 增加了负担，势必会影响 应用程序 吞吐量。


基于以上两点，  是否移动对象都存在弊端， 移动则内存回收时更复杂， 不移动则内存分配时更复杂。
从垃圾收集的停顿时间来看， 不移动对象 的停顿时间会更短，甚至可以不需要停顿。
但是 从 吞吐量上来看， 移动对象会更划算。

虽然 不移动对象会使得 垃圾收集效率提升一些，单 因为内存碎片 导致 内存分配和内存访问 效率更低，且 内存分配 和内存访问  相比 垃圾收集 的 频率要高的多，这部分的耗时 更高，
所以 总的来说， 移动存活对象 的 吞吐量是要高一些的。

所以 如果 关注 低延迟，则使用  不移动的 标记清除算法；如果关注 高吞吐，则 使用 移动的 标记整理算法。
tips: Parallel Scavenge 关注高吞吐，所以Parallel Scavenge 的老年代版本Parallel old 就采用了标记-整理，  CMS关注 低延迟就采用了  标记-清除。


还有一种两种都用的方式。 让 虚拟机 平时 大多数时间  都采用标记-清除 算法，暂时容忍 内存碎片，一直到内存空间的碎片化
已经 特别严重了，这时候，就采用 标记-整理 收集一次，来 获得 规整的 内存空间。
基于 标记-清除的 关注 低延迟的 CMS收集器就是 这样干的。