zk是一个 开源的 分布式协调服务， 有 雅虎创建，Google Cubby的开源实现。 
设计目标是 将那些复杂容易出错的分布式一致性服务 封装起来，构成一个高效可靠的 原语集，并 以一系列 简单的接口 提供给用户使用。


zk可以保证如下 分布式一致性：
1. 顺序一致性：  从同一个客户端发起的事务请求，最终将会严格地 按照 其发起顺序 被应用到 zk中
2. 原子性：是有事务的请求处理结果  在整个集群上 所有机器上的应用应该都是一致的，也就是说，要么整个集群机器都成功 应用了某一个事务，要么都没有应用。
3. 单一视图：  无论客户端连接到的 是哪个 zk服务器，它 看到的 服务端 数据模型 都是一致的
4. 可靠性  ：zk **仅仅保证 一定时间 内**，客户端 始终 能够 从服务器上  读取到 最新的数据状态。

# zk设计目标
- zk致力于 提供一个 高性能，高可用，且具有**严格的顺序访问控制能力（主要是 写操作的 严格顺序性）的分布式协调服务**

>高性能使得zk 能够应用于 那些 对系统 吞吐量 有明确要求的 大型分布式系统;
> 高可用 使得 分布式的单点 问题 得到了很好的 解决;
> 严格 的 顺序访问 控制 使得客户端 能够 基于 zk 实现一些 复杂的 同步原语;


## 四个 设计目标：
1. 简单的数据模型
   - zk使得 分布式程序  能够通过一个**共享的树形结构**的 名字空间 来进行相互协调。
2. 可以构建集群
    - 组成zk集群的**每台机器都会 在内存中维护一个 当前的服务器状态**，并且每台机器之间都互相 保持着通信
    - 值得一提的是，只要**集群中超过 一半 的机器能够正常工作**，那么整个集群就能够 正常 对外服务
    - zk客户端 会选择 跟集群的任意一台机器  来参加 tcp连接，
      而 一旦 客户端与  某台 zk服务器 之间的 连接断开之后，客户端 会自动 连接到 集群中的 其他机器。
3. 顺序访问
    - 对于来自 客户端的 每个 更新请求，zk都会 分配 一个全局唯一的 递增编号，这个 编号反映 了所有 事务操作的先后顺序，
    - 应用程序 可以使用 zk的这个 特性来实现 更高层次的 同步原语。
    
4. 高性能
    - 由于 zk 将**全量数据 存储 在内存中**，并 直接服务与客户端 的 所有非 事务请求， 所以 zk 尤其 适用 于**以读操作为 主的应用场景**
    

# zk基本概念

## 集群角色
通常在分布式系统中，构成集群的每一台机器都有自己的角色，最典型的集群模式 就是 master/slave(主备），
在这种模式中，我们把 能够 **处理所有 写操作 的 机器 称为 master**，把 所有 通过 异步 复制方式 获取 最新数据，
并提供 读 服务的 机器 称为  slave机器


but。。。。 但是， zk并没有 沿用。

引入了 Leader，Follower， Observe 三种角色。
-  zk集群中的机器 通过一个 leader 选举过程来 选定 一台 被称为 “Leader" 的机器， Leader服务器  为 客户端 提供 **读和写服务**
-  Follower 和 Observe 都能够 提供 **读服务**，唯一 的 却别 就是 Observe 不参与 Leader 的选举。
-  Observe也不参与 写操作的  “过半写成功”策略。  所以 Observe 可以在 不影响 写 性能 的情况下 提升 集群的 读性能。

## 会话session
Session是  指 客户端会话
>在 zk 中，一个 客户端连接 是 指 客户端 和 服务器 之间的 TCP 长链接
> zk对外的 服务端口默认是 2181 ， 客户端 启动的时候， 首先 会  跟 服务器 建立 一个 TCP连接


从 第一次 连接 建立 开始， 客户端 会话 的 生命周期也开始了，
通过这个 连接，客户端 
- 能够通过 **心跳 检测 与服务器   保持有效的 会话**
- 也能够 向 zk服务器 **发送 请求 并 接受 响应** 
- 同时 也能 通过这个 连接 **接收来自 服务器 的 watch 事件通知**

Session的  sessionTimeout 的值  用来 设置一个 **客户端 会话的超时 时间**。

当 由于 服务器 压力大，网络故障，或者是  客户端 主动断开 连接等  各种原因 导致客户端 断开连接， 
***只要 在 这个 sessionTimeout 时间内 ，重新连接上 集群的  任意一台机器，那么 之前 创建的 会话 仍然 有效***。

## 数据节点（Znode）
zk中有两种节点： 机器节点， 数据节点。
zk的所有 数据 存在 内存中， 数据 模型 是一棵树（Znode Tree),  用斜杠（“/"),  进行分割 的路径，就是  一个 Znode， 
>例如：  /foo/path1 。 每个 Znode 上 都会 保存 自己的 数据 内容，同时 保存 一系列 属性 信息。

Znode 氛围 临时节点 和 持久节点。
- 持久节点： 一旦Znode 被创建， 除非 主动 进行 Znode 的 移除操作，否则这个 Znode将会一直保存
- 临时节点： 它的 **生命周期 跟 客户端会话session 保持一致**，一旦session 失效，那么 这个 客户端创建 的 临时 节点 也会 被 移除。

另外 zk 允许 用户 为 每个节点  添加一个 特殊 的 属性： **sequential（SEQUENTIAL)**，
一旦 节点 被标记 上 这个 属性，那么 这个 节点 被创建的 时候，zk会 自动 在 其节点 后面追加上 一个 整型数字，
这个 整型数字 就是  一个 由**父节点 维护的 自增数字**。

## 版本
对于 Znode ， zk都会 维护一个  Stat的 数据结构， 记录三个数据
1. Version （ 当前 Znode的 版本）
2. Cversion（当前Znode  子节点 的版本）
3. Aversion（ 当前 Znode 的 ACL 版本）

## watcher
Watcher 时间监听器，是 一个 很重要的特性。
- Zk  允许 用户 在 指定 节点 上 注册 一些 Watcher，并且 在 一些特定 事件 触发的时候，  
- zk会 将 事件 通知到 感兴趣 的客户端上去。 
  
***该机制 是 zk 实现 分布式 协调服务 的 重要 特性***。

## ACL
zk采用 ACL (Access  Control Lists) 策略 来进行 权限控制。 
类似 linux 文件系统的权限 控制。zk定义的  以下 5 种 权限：
- CREATE ： 创建 子节点的 权限
- READ ： 获取 节点 数据 和 子节点 列表 ~
- WRITE ： 更新 节点数据 ~
- DELETE ： 删除 子节点数据 ~
- ADMIN ： 设置 ACL 的 权限

注意： CREATE  ，DELETE 都是 针对 子节点 的权限控制


# ZAB
zk并没有完全采用 Paxos， 而是 使用了 一种 称为 **ZAB（zookeeper atomic broadcast）原子消息广播协议**，
来作为  其 数据一致性 的 核心算法。

ZAB协议是 为 分布式 协调服务  zk专门 设计的 的 一种支持 崩溃 恢复的 原子广播协议。**特别为 zk设计**。

基于zab， zk实现了一种 主备模式的 系统架构 来保持 **集群中 各个 副本 之间的 数据一致性**。
- Zk 使用 一个 单一的 主进程  来接收  来自客户端 的 所有事务请求。
- 并 采用 ZAB，  将 服务器 数据状态变更 以**事务 Proposal 的形式 广播 到所有的 副本进程**上去
- ZAB 协议的 这个 主备模型 架构  **保证了 同一时刻 集群中  只能有一个 主进程 来广播服务器的 状态变更**。 
  因此 能够 很好 的 处理 客户端 大量的 并发请求。

另一方面，考虑到 分布式 环境中， **顺序执行** 的 一些状态变更 其前后 会存在一定的 依赖关系  
有些状态 变更 必须 依赖 与  比它  早生成的 那些状态变更。
这样的依赖关系 也对 ZAB提出了 一个 要求：
- ZAB协议 必须能够 保证 一个 全局的 变更 序列被 顺序的应用.
  也就是 说，ZAB协议 需要 保证 如果一个 状态变更 已经被处理了，那么所有的 它依赖的  状态变更  都应该 已经 提前被处理了。


最后考虑到 **主进程任何时候 都有可能  出现崩溃或 重启现象**， 
因此 ZAB 还 需要 做好  当前主进程 异常 情况的 时候，依然 能够正常工作。


AB协议 的 核心 是 定义了 对于 那些 **会改变 zk服务器 状态**的 事务请求 的 **处理方式**，
即：
   所有事务请求必须有一个**全局唯一的服务器**来协调处理，这样的 服务器 被称为**Leader服务器**,而
   余下的服务器则称为 **Follower 服务器**。

1. Leader 服务器 负责 将一个 客户端的 事务请求 转化成 一个 事务 Proposal（提议），并 将 该 Proposal 分发 给 集群中的 所有 Follower服务器
2. 之后Leader 需要 等待 所有的 Follower 反馈
3. 一旦 超过  **半数 的 Follower 进行了 正确的反馈后**， 那么 Leader 就会  再次向 所有的Follower 分发 Commit 消息，要求  其 将 前一个 Proposal 进行提交

ZAB包括两种基本的模式，分别是**崩溃恢复 和 消息广播**。

>崩溃恢复：
> 整个 服务框架 在启动过程中，或 是 当 Leader 服务器 出现 网络中断 、崩溃退出 与 重启 等异常情况时，
  ZAB协议就会 进入 **恢复模式** 并**选举 产生 新的 Leader服务器**
 选举产生了 **新的 leader服务器**，同时 **集群中 已经有过半的机器 与该 Leader 服务 完成了 状态同步之后**，  ZAB协议 就会 退出 恢复模式  

其中，所谓 的 状态同步 是 指 数据同步，用来保证 集群中 过半的 机器 能够 和 Leader 服务器 的 数据状态 保持一致。

>消息广播：
> 当集群中 **已经有过半的 Follower服务器 和 Leader 服务器 的 状态同步**，那么整个 服务框架 就可以 进入 消息广播模式了。


当一台 **同样 遵守 ZAB 协议的 服务器 启动后 加入 到集群中**时，如果 此时 已经存在一个 leader 服务器 在负责 进行 消息广播，
那么 **新加入的 服务器 就会 自觉 进入  数据恢复模式**

- zk设计成 只允许一个 Leader 服务器 来 进行事务请求的 处理。
- Leader 服务器 在 接收 到 客户端的 事务请求后，会 生成 对应的 事务提案（Proposal） 并发起一轮广播协议；
  如果集群中的其他机器 接收 到客户端的 事务请求，那么 这些**非 Leader 服务器 会 首先将 这个 事务 转发 给 Leader服务器**。

当Leader 服务器出现  **崩溃 或者 机器重启，亦或是 集群中 已经 不存在 过半服务器 与 该Leader 服务器 保持 正常通信**时，
那么 在 重新开始 新一轮 的原子广播 事务操作之前，所有 进程 首先 会使用 崩溃恢复 协议 来使 彼此到达一个  一致的状态，
于是 整个 ZAB 流程 就会从消息广播 模式 进入 崩溃恢复模式。

一个  机器 **想要称为 Leader 必须获得 过半进程的 支持**。同时 由于 每个进程 都有可能会崩溃，因此 ZAB协议 运行过程中，
前后  会 出现多个 Leader， 并且 每个进程 也可能 会 多次称为 Leader。 
进入 崩溃恢复 模式后，**只要 集群中 存在过半机器 能够正常 通信，那么 就可以 产生一个 新的 Leader**  并 再次进入 消息广播模式。

>例如：
一个 由 3台机器 组成的 ZAB服务，通常 由 1个Leader  2个Follower机器组成。某个 时刻，加入 其中的 一个 Flower  挂了， 整个ZAB集群不会 中断服务，这是因为 leader 仍然能够获得 过半（包括Leader 自己）的支持。

## 消息广播
ZAB协议的**消息广播过程使用的是一个原子广播协议**， 类似于一个 **二阶段提交**的过程。
针对 客户端的 事务请求，Leader 服务器 会为  这个事务请求 生成 对应的 Proposal（提案），并 将 Proposal 发送给  其他所有 机器，
然后 在 分别 收集 各自的选票，最后进行事务提交。

![img.png](images/消息（提案Proposal）广播示意图.png)

- 这里 跟 标准的 2PC 流程 略有不同 。 在 zab的 二阶段提交过程中，**移除了 中断的 逻辑**，
所有的Follower  要么正常反馈 leader 提出的 Proposal，要么 就**抛弃 这个 Proposal** （而不是 中断带来的回滚）

-  同时 ZAB 将 2PC中的  中断逻辑 移除 意味着:   
   - 我们可以在 **过半的Follower 都反馈响应Ack之后， 就开始 提交 Proposal事务**，而不需要 等待所有的 Follower 都反馈响应

当然，这种 简化了的 二阶段提交  模型下，是**无法 处理 Leader  服务器 崩溃 退出 带来的  数据不一致问题**
因此  ZAB 协议中 添加了  另一个 模式， 即 **采用 崩溃恢复 模式** 来解决这个 问题


另外 整个 消息广播 协议 是基于  具有 **FIFO 特性的 TCP 来进行 网络通信**的， 因此 能够 保证 消息广播过程中 **消息接收 与 发送的 顺序性**。

- 在广播过程中，Leader 会为 **每个Follower 都 各自分配一个 单独的 队列**， 然后  将 需要广播的事务
  Proposal依次放入  队列中，并且根据 FIFO 策略进行 消息发送
- 每一个 Follower 在收到这个 事务Proposal之后，都会 **首先  以事务日志 的形式 写入到 本地磁盘中去，并且 成功写入之后**  反馈 给 leader 服务器 一个 Ack 响应  
- 当Leader 服务器 接收 到 超过 半数 Follower 的 Ack响应后，就会 广播一个 Commit 消息 发送给 所有的 Follower 通知其 进行事务提交
- 同时 Leader 也会 完成 对事务的提交， 每个 Follower 在接收到 Commit 之后，也会完成 对事务 的提交

## 崩溃恢复
ZAB的 消息广播过程，正常情况下运行非常良好，但是 一旦 Leader 服务器 崩溃，或者 由于网络原因 **导致 Leader 与 过半的Follower 失去联系**，
那么 就会 进入崩溃恢复模式。

在ZAB 中，为了保证程序运行，整个恢复 过程 结束后 需要 选举出 一个 新的 Leader服务器。
因此 ZAB 需要一个 高效且可靠 的Leader 选举 算法， 从而 保证 能够 快速选举出新的 Leader ，
同时 还需要让集群中的 所有 其他机器 也能够 快速 地感知 到 选举产生 的 新的 Leader

>我们知道，ZAB规定了 一个 事务Proposal 在一台机器上被处理成功，那么 应该在 所有的机器上 都被处理成功，哪怕 机器出现 故障崩溃。 

来看看 崩溃恢复过程中，可能 会 出现 两个数据不一致性 的 隐患 ，以及 针对这些 ZAB 需要 保证的 特性。


ZAB需要保证那些已经在Leader服务器上 被提交了，并且已经得到 过半Follower 服务器Ack反馈，
但是 **它将 Commit 消息发送 给所有的 Follower 之前，Leader挂了**。