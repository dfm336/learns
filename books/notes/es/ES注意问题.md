# 明确使用的ES 版本

- ES 的各个版本变化都比较大。 特别是 6.x 之后的版本， 有很多变化。
- 语法， 集群， 配置， 集群健康状态， 集群节点， 索引， 分片， 副本， 以及各种API 都有很大变化。


- Elasticsearch 7.0.0中，**移除了包括type**、script_fields、cluster.routing.allocation.awareness.attributes等。此外，7.0.0还引入了新的索引格式和默认设置，以提高性能和可靠性。

- Elasticsearch 6.0.0中，移除了包括river、tribe节点、percolator等。此外，6.0.0还引入了新的索引格式和默认设置，以提高性能和可靠性。

- Elasticsearch 5.0.0中，移除了包括type、script_fields、percolator等。此外，5.0.0还引入了新的索引格式和默认设置，以提高性能和可靠性。

- Elasticsearch 2.x版本中，移除了包括type、script_fields、facets等。此外，2.x版本还引入了新的索引格式和默认设置，以提高性能和可靠性。


# 对ES 的写入失败， 重试机制
当写入操作失败时，应用程序可以根据具体情况采取不同的处理方式。以下是一些可能的处理方式：

- 重试写入操作：如果写入操作失败，应用程序可以尝试再次执行写入操作。在重试之前，应用程序可以等待一段时间，以便Elasticsearch可以恢复并解决任何可能导致写入失败的问题。
- 回滚事务：如果应用程序中的多个写入操作被视为一个事务，则可以回滚整个事务，并撤销之前的所有写入操作。
- 记录错误日志：应用程序可以记录所有写入失败的操作和相关错误信息，并将其记录到应用程序的日志文件中。这有助于诊断问题并采取必要的措施来解决它。
- 通知管理员：如果写入操作失败是由于硬件故障或网络问题等无法解决的问题导致的，则应用程序可以通知管理员以寻求帮助。

总之，应用程序应该能够处理写入失败的情况，并采取必要的措施来确保数据的一致性和可靠性。

常见写入失败原因：
以下是一些可能导致写入操作失败的常见原因：

- 写入的文档包含无效的JSON格式，导致写入失败。
- 索引已经被锁定，因为它正在进行备份或恢复操作。
- 硬件问题或网络问题导致写入失败。
- 索引已经达到了最大容量或最大文档数量限制。

# Bulk 操作的 429状态码 （如果 version < 6.8.0)
产生原因：
> bulk 请求 放入ES 队列， 当队列满时，新请求会被拒绝， 并返回 客户端 429状态码。

 客户端需要  处理这个状态码， 并在稍后 重发请求（ 重试）。
 此刻 客户端 需要处理 bulk 请求中 部分成功，部分失败的情况。
 

这种情况产生在：  协调节点 转发基于 分片 的请求到数据节点时，有可能 因为 对方（数据节点）的 队列满了 而 拒绝 写操作。
但是 其他 数据节点 却正常 处理了。 


客户端需要将 返回了 429 状态码的 对应数据 重试写入， 而不是所有数据。 否则重复写入。 （考虑 幂等写入）

 注意： ES 6.8.0 之后的版本， 会自动重试 429 状态码的请求。
 

# 小心使用fielddata 
es 聚合 agg 会使用doc_value 获取字段值，但是 text 类型不支持 doc_values. 当 text 类型 用在 聚合时，就会依赖 fielddata。

fielddata性能损耗原因：
- fielddata 是 在聚合，排序， 或者脚本中 根据需要。动态创建的，
- 需要 读取 每个分段中的 整个倒排索引， 并 反转 倒排索引（ term 和 doc关系），然后 存到 JVM， 代价昂贵， 用户明显感受 delay

>ps:
> 在Elasticsearch中，聚合（aggregation）操作通常是通过doc_values机制实现的。
> doc_values是一种基于列存储的数据结构，它可以用于存储结构化数据类型（如数字、日期等）的字段值，
> 并且可以用于排序、聚合、脚本和列投影等操作。因此，在使用聚合操作时，如果您的字段是结构化数据类型，那么Elasticsearch会自动使用doc_values机制来进行聚合操作。


解决：
如果您需要对一个字段既进行全文搜索，又需要进行聚合操作，可以考虑使用**multi-fields（多字段）功能**。
multi-fields可以让您将同一个字段同时设置为不同类型的子字段，以满足不同的需求。

```java
{
  "mappings": {
    "properties": {
      "my_field": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword"
          }
        }
      }
    }
  }
}

```

体来说，您可以将该字段设置为text类型，并同时创建一个keyword类型的子字段。
这样，在进行全文搜索时，Elasticsearch会使用text类型的字段进行匹配；
而在进行聚合操作时，Elasticsearch会使用keyword类型的子字段进行聚合。这种方法可以同时满足全文搜索和聚合操作的需求，

但需要注意的是，由于需要存储两个字段的数据，可能会占用更多的存储空间。


总结： 
 小心使用fielddata是一个普遍存在的问题，不仅仅局限于某个特定版本的Elasticsearch。fielddata机制是一种基于行存储的数据结构，用于存储文本类型字段的分词结果。由于需要进行分词和分析操作，fielddata的性能可能会受到影响，并且会消耗大量的内存资源。

因此，在使用Elasticsearch时，应该尽量避免使用fielddata机制，以减少内存消耗和提高性能。具体来说，可以通过以下几种方式来避免使用fielddata：

对于文本类型的字段，尽量使用全文搜索功能，而不是聚合操作。全文搜索可以通过倒排索引（inverted index）来实现，不需要使用fielddata机制。

对于需要进行聚合操作的字段，可以将其设置为keyword类型，而不是text类型。keyword类型不需要进行分词和分析操作，可以直接进行聚合操作。

对于需要使用fielddata机制的字段，可以通过控制其内存使用量来避免过度消耗系统资源。具体来说，可以通过在字段映射中设置“fielddata_frequency_filter”参数来限制fielddata机制的使用范围。

总之，小心使用fielddata是一个普遍存在的问题，应该在使用Elasticsearch时格外注意。通过避免使用fielddata机制，可以减少内存消耗和提高性能。


# ES 的 mapping 设计在以下方面可能会面临挑战：

动态 mapping：ES 的 mapping 设计支持动态添加字段，这对于数据结构不稳定或者频繁变化的场景非常有用。但是，如果动态 mapping 不加限制，可能会导致字段数量过多、类型不一致等问题，从而影响查询性能和数据质量。
字段类型：ES 的 mapping 设计支持多种数据类型，包括基本类型、嵌套类型、地理位置类型等。但是，如果选择不合适的数据类型，可能会导致数据存储和查询时的性能问题。
索引设计：ES 的 mapping 设计支持多种索引类型，包括倒排索引、FST 索引等。但是，如果索引设计不合理，可能会导致查询性能下降或者占用过多的存储空间。
分析器配置：ES 的 mapping 设计支持自定义分析器，这对于不同语言或者场景下的分词需求非常有用。但是，如果分析器配置不合理，可能会导致分词错误、搜索结果不准确等问题。
映射更新：ES 的 mapping 设计支持动态更新映射，但是这可能会导致索引重建、数据迁移等问题。因此，在更新映射时需要谨慎考虑，并且需要进行备份和测试。

总之，在设计 ES 的 mapping 时需要考虑多个方面，并且需要根据具体场景进行优化和调整。


## mapping中各个部分的介绍
在Elasticsearch中，mapping是用于定义索引中字段的数据类型和属性的过程。下面是：

1. Properties（属性）：定义了索引中包含的字段及其属性。每个属性包括字段的名称、数据类型、索引选项、存储选项、分析器等。
2. Fields（字段）：定义了在索引中为每个属性存储的实际字段。例如，对于一个文本属性，可以使用多个字段来存储原始文本、分词后的文本、大写或小写文本等。
3. Data types（数据类型）：定义了每个属性的数据类型。Elasticsearch支持多种数据类型，包括文本、数字、日期、布尔值等。
4. Index options（索引选项）：定义了索引是否会为该属性创建倒排索引。如果设置为不索引，则该属性将无法进行全文搜索。
5. Store options（存储选项）：定义了是否在文档中存储该属性的值。如果设置为不存储，则无法检索该属性的值。
6. Analyzer（分析器）：定义了在索引文本属性时要使用的分析器。分析器负责将文本分成单词，并将这些单词转换为标准化格式，以便进行全文搜索。
7. Dynamic templates（动态模板）：定义了如何处理未知字段。如果未知字段出现在文档中，动态模板将根据其名称和数据类型自动创建相应的属性。
8. Meta fields（元字段）：定义了一些特殊字段，这些字段可以用于控制搜索结果的行为，例如_score、_source和_id等。
以上是Elasticsearch mapping中各个部分的介绍。理解这些概念可以帮助您更好地设计和管理Elasticsearch索引。


粗略版：
当您在Elasticsearch中创建商品索引时，可以使用以下示例mapping定义商品索引中的字段和属性：

```
{
  "mappings": {
    "properties": {
      "id": {
        "type": "keyword"
      },
      "name": {
        "type": "text"
      },
      "description": {
        "type": "text"
      },
      "price": {
        "type": "double"
      },
      "brand": {
        "type": "keyword"
      },
      "category": {
        "type": "keyword"
      },
      "tags": {
        "type": "keyword"
      },
      "created_at": {
        "type": "date",
        "format": "yyyy-MM-dd HH:mm:ss"
      }
    }
  }
}
```

上述mapping定义了商品索引中的以下字段和属性：

- id：商品的唯一标识符，使用关键字数据类型存储。
- name：商品的名称，使用文本数据类型存储。
- description：商品的描述，使用文本数据类型存储。
- price：商品的价格，使用双精度浮点数数据类型存储。
- brand：商品的品牌，使用关键字数据类型存储。
- category：商品所属的类别，使用关键字数据类型存储。
- tags：商品的标签，使用关键字数据类型存储。
- created_at：商品创建的日期和时间，使用日期数据类型存储，并指定了日期格式。

这是一个简单的商品mapping示例，您可以根据需要添加其他字段和属性。



详细：
当您在Elasticsearch中创建商品索引时，可以使用以下示例mapping定义商品索引中的字段和属性，并包含更详细的设置：

```
{
  "mappings": {
    "properties": {
      "id": {
        "type": "keyword",
        "index": false
      },
      "name": {
        "type": "text",
        "analyzer": "standard",
        "fields": {
          "keyword": {
            "type": "keyword"
          },
          "autocomplete": {
            "type": "completion"
          }
        }
      },
      "description": {
        "type": "text",
        "analyzer": "english",
        "fields": {
          "keyword": {
            "type": "keyword"
          }
        }
      },
      "price": {
        "type": "double",
        "index": true,
        "store": true
      },
      "brand": {
        "type": "keyword",
        "index": true,
        "doc_values": true
      },
      "category": {
        "type": "keyword",
        "index": true,
        "doc_values": true
      },
      "tags": {
        "type": "keyword",
        "index": true
      },
      "created_at": {
        "type": "date",
        "format": "yyyy-MM-dd HH:mm:ss"
      }
    }
  }
}
```

上述mapping定义了商品索引中的以下字段和属性，并包含更详细的设置：

- id：商品的唯一标识符，使用关键字数据类型存储。在此示例中，将其设置为不索引。
- name：商品的名称，使用文本数据类型存储。在此示例中，使用标准分析器进行分析，并添加了两个子字段：一个是关键字类型的字段，另一个是自动完成类型的字段。
- description：商品的描述，使用文本数据类型存储。在此示例中，使用英语分析器进行分析，并添加了一个关键字类型的子字段。
- price：商品的价格，使用双精度浮点数数据类型存储。在此示例中，将其设置为索引和存储。
- brand：商品的品牌，使用关键字数据类型存储。在此示例中，将其设置为索引和使用doc_values。
- category：商品所属的类别，使用关键字数据类型存储。在此示例中，将其设置为索引和使用doc_values。
- tags：商品的标签，使用关键字数据类型存储。在此示例中，将其设置为索引。
- created_at：商品创建的日期和时间，使用日期数据类型存储，并指定了日期格式。

这是一个更详细的商品mapping示例，您可以根据需要添加其他字段和属性，并根据需要调整每个字段的设置。


# 避免索引巨大的文档


# 使用注意
- 怎么初始化 索引？ 索引怎么设计？  某个索引   固定频率都有写（新增）的话， 需要考虑 索引轮转。日期规则， 将索引设置写入模板。
- 删除索引，也可以 按照 日期 删除， 删除索引 会立即 删除磁盘，释放空间。 如果 只删除 doc， 需要等待 Lucene 的  段合并。
- 分词器 用的哪个？ 又可能 泰文， 越南文？
- 

# ES 服务器注意
- ES 服务器 最好 只用于ES
- ES很依赖 os cache 命中， 所以 需要 为 Lucene 预留 50% 
- ES 的 服务器 需要 关闭 swap 。当一个 申请内存的，  遇见 物理内存不足， 宁可让 请求 失败。 swapoff，种磁盘交换操作会严重影响Elasticsearch的读写性能，因为磁盘的读写速度远远低于内存的读写速度。









