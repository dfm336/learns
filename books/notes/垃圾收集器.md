如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的实践者。
各款经典收集器之间关系如图，存在连线说明可以搭配使用。
![img_1.png](img_1.png)

没有最好的，万能的收集器，只能根据场景选择最合适的。

# Serial 收集器
Serial是最基础、历史最悠久的收集器。这是一款 单线程 工作的收集器，
单线程 并不仅仅是 说明它只会 使用一个处理器 或者 一个收集器 线程 去进行 GC工作。
更应该强调，它 在 GC工作时， 需要 "Stop The World"。  这项工作时 虚拟机 后台自动发起的，
在用户不可知， 不可控的情况下， 把 用户的工作线程 全部停掉。 这对很多应用来说是不可接受的。
![img_2.png](img_2.png)

但是对于 Hotspot 的设计者来说，是可以理解"Stop The World"的。你总不能一边清理垃圾，一边又 制造垃圾吧。

但是 都为着 消除或降低 GC时 停顿用户线程的 时间而努力着。

Serial  -》 Parallel -》 CMS 和 G1 -》 Shenandoah 和 ZGC 
一步一步的， 都 没有办法 根除 Stop The world


虽然 Serial 最早，但至今 也是 HopSpot 运行在客户端模式下的 默认  新声代  收集器。
优点就是， 它 简单 高效（对于 其他的 单线程 而比）。
对于内存资源受限的环境，它是 所有 收集器里 额外 消耗内存 最小的；
对于单核处理器或者核心较少的环境来说，Serial由于没有 线程交互的开销，专心GC 自然可以获得 最高的 单线程收集效率。

桌面应用，一般分配给 jvm的内存不会太多， 新生代的内存就更少，一般 几十 或者一两百 MB。 垃圾收集的停顿完全可以控制在 十几、几十毫秒
以内。 只要不是频繁收集， 这个 停顿时间 是完全可以接受的。
所以  Serial 对于 客户端 Jvm来说 是一个 很好的 选择。

# ParNew 收集器
ParNew其实是 Serial的多线程并行版本。除了 同时 使用多条线程进行GC外，其余 都跟 Serial一致。
![img_3.png](img_3.png)

ParNew 除了 多线程 并行收集之外，对比Serial并没有太多创新。但是在jdk1.7之前，它却是 服务端 Hotspot的首选收集器。
有一个 跟性能无关的  很大原因就是： 除了 Serial ，只有它 能跟  CMS搭配工作。

- 

