zk是一个 开源的 分布式协调服务， 有 雅虎创建，Google Cubby的开源实现。 
设计目标是 将那些复杂容易出错的分布式一致性服务 封装起来，构成一个高效可靠的 原语集，并 以一系列 简单的接口 提供给用户使用。


zk可以保证如下 分布式一致性：
1. 顺序一致性：  从同一个客户端发起的事务请求，最终将会严格地 按照 其发起顺序 被应用到 zk中
2. 原子性：是有事务的请求处理结果  在整个集群上 所有机器上的应用应该都是一致的，也就是说，要么整个集群机器都成功 应用了某一个事务，要么都没有应用。
3. 单一视图：  无论客户端连接到的 是哪个 zk服务器，它 看到的 服务端 数据模型 都是一致的
4. 可靠性  ：zk **仅仅保证 一定时间 内**，客户端 始终 能够 从服务器上  读取到 最新的数据状态。

# zk设计目标
- zk致力于 提供一个 高性能，高可用，且具有**严格的顺序访问控制能力（主要是 写操作的 严格顺序性）的分布式协调服务**

>高性能使得zk 能够应用于 那些 对系统 吞吐量 有明确要求的 大型分布式系统;
> 高可用 使得 分布式的单点 问题 得到了很好的 解决;
> 严格 的 顺序访问 控制 使得客户端 能够 基于 zk 实现一些 复杂的 同步原语;


## 四个 设计目标：
1. 简单的数据模型
   - zk使得 分布式程序  能够通过一个**共享的树形结构**的 名字空间 来进行相互协调。
2. 可以构建集群
    - 组成zk集群的**每台机器都会 在内存中维护一个 当前的服务器状态**，并且每台机器之间都互相 保持着通信
    - 值得一提的是，只要**集群中超过 一半 的机器能够正常工作**，那么整个集群就能够 正常 对外服务
    - zk客户端 会选择 跟集群的任意一台机器  来参加 tcp连接，
      而 一旦 客户端与  某台 zk服务器 之间的 连接断开之后，客户端 会自动 连接到 集群中的 其他机器。
3. 顺序访问
    - 对于来自 客户端的 每个 更新请求，zk都会 分配 一个全局唯一的 递增编号，这个 编号反映 了所有 事务操作的先后顺序，
    - 应用程序 可以使用 zk的这个 特性来实现 更高层次的 同步原语。
    
4. 高性能
    - 由于 zk 将**全量数据 存储 在内存中**，并 直接服务与客户端 的 所有非 事务请求， 所以 zk 尤其 适用 于**以读操作为 主的应用场景**
    

# zk基本概念

## 集群角色
通常在分布式系统中，构成集群的每一台机器都有自己的角色，最典型的集群模式 就是 master/slave(主备），
在这种模式中，我们把 能够 **处理所有 写操作 的 机器 称为 master**，把 所有 通过 异步 复制方式 获取 最新数据，
并提供 读 服务的 机器 称为  slave机器


but。。。。 但是， zk并没有 沿用。

引入了 Leader，Follower， Observe 三种角色。
-  zk集群中的机器 通过一个 leader 选举过程来 选定 一台 被称为 “Leader" 的机器， Leader服务器  为 客户端 提供 **读和写服务**
-  Follower 和 Observe 都能够 提供 **读服务**，唯一 的 却别 就是 Observe 不参与 Leader 的选举。
-  Observe也不参与 写操作的  “过半写成功”策略。  所以 Observe 可以在 不影响 写 性能 的情况下 提升 集群的 读性能。

## 会话session
Session是  指 客户端会话
>在 zk 中，一个 客户端连接 是 指 客户端 和 服务器 之间的 TCP 长链接
> zk对外的 服务端口默认是 2181 ， 客户端 启动的时候， 首先 会  跟 服务器 建立 一个 TCP连接


从 第一次 连接 建立 开始， 客户端 会话 的 生命周期也开始了，
通过这个 连接，客户端 
- 能够通过 **心跳 检测 与服务器   保持有效的 会话**
- 也能够 向 zk服务器 **发送 请求 并 接受 响应** 
- 同时 也能 通过这个 连接 **接收来自 服务器 的 watch 事件通知**

Session的  sessionTimeout 的值  用来 设置一个 **客户端 会话的超时 时间**。

当 由于 服务器 压力大，网络故障，或者是  客户端 主动断开 连接等  各种原因 导致客户端 断开连接， 
***只要 在 这个 sessionTimeout 时间内 ，重新连接上 集群的  任意一台机器，那么 之前 创建的 会话 仍然 有效***。

## 数据节点（Znode）
zk中有两种节点： 机器节点， 数据节点。
zk的所有 数据 存在 内存中， 数据 模型 是一棵树（Znode Tree),  用斜杠（“/"),  进行分割 的路径，就是  一个 Znode， 
>例如：  /foo/path1 。 每个 Znode 上 都会 保存 自己的 数据 内容，同时 保存 一系列 属性 信息。

Znode 氛围 临时节点 和 持久节点。
- 持久节点： 一旦Znode 被创建， 除非 主动 进行 Znode 的 移除操作，否则这个 Znode将会一直保存
- 临时节点： 它的 **生命周期 跟 客户端会话session 保持一致**，一旦session 失效，那么 这个 客户端创建 的 临时 节点 也会 被 移除。

另外 zk 允许 用户 为 每个节点  添加一个 特殊 的 属性： **sequential（SEQUENTIAL)**，
一旦 节点 被标记 上 这个 属性，那么 这个 节点 被创建的 时候，zk会 自动 在 其节点 后面追加上 一个 整型数字，
这个 整型数字 就是  一个 由**父节点 维护的 自增数字**。

## 版本
对于 Znode ， zk都会 维护一个  Stat的 数据结构， 记录三个数据
1. Version （ 当前 Znode的 版本）
2. Cversion（当前Znode  子节点 的版本）
3. Aversion（ 当前 Znode 的 ACL 版本）

## watcher
Watcher 时间监听器，是 一个 很重要的特性。
- Zk  允许 用户 在 指定 节点 上 注册 一些 Watcher，并且 在 一些特定 事件 触发的时候，  
- zk会 将 事件 通知到 感兴趣 的客户端上去。 
  
***该机制 是 zk 实现 分布式 协调服务 的 重要 特性***。

## ACL
zk采用 ACL (Access  Control Lists) 策略 来进行 权限控制。 
类似 linux 文件系统的权限 控制。zk定义的  以下 5 种 权限：
- CREATE ： 创建 子节点的 权限
- READ ： 获取 节点 数据 和 子节点 列表 ~
- WRITE ： 更新 节点数据 ~
- DELETE ： 删除 子节点数据 ~
- ADMIN ： 设置 ACL 的 权限

注意： CREATE  ，DELETE 都是 针对 子节点 的权限控制


# ZAB

    

